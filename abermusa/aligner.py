''' Carries out alignment and scoring. Fester/multiprocessor execution is abstracted through the exewrapper class (see appropriate file). Running an alignment transitions between two states: execution of commands and scoring of output. '''

# Date:   May 10 2013
# Author: Alex Safatli
# E-mail: safatli@cs.dal.ca

import glob, os, cPickle, math, traceback
import scoring
from reference import reference # TODO: Eventually, can wrap all calls to "ref" in this.
from labblouin import IO, PDBnet, homology, timer
from labblouin.logfile import XMLfile, timeToString

def handleReference(args,ref,exe,logf):
    
    ''' Check reference folder status (and all its files). '''

    # Preparation steps.
    rf = ref.folder_name    # Folder name.
    if ref.isScored():      return False
    elif rf not in exe.ran: return False
    fl = exe.ran[rf].keys() # List of files.
    
    # Data structure initialization.
    failed,fdetails,scored,scores,pvals = [],[],[],{},{}
    sctype = None
    
    # For all files...
    for f in fl:
        
        # Infer metadata.
        name = IO.getFileName(f) 
        pr   = IO.join(rf,name) # Prefix.
        scfi = IO.withExtension(pr,"pickl") # Score file.
        pdbf = IO.withExtension(pr,"pdb") # PDB file.
        outf = IO.withExtension(pr,"out") # Output file from plugin aligner.
        trbf = IO.withExtension(pr,"dump") # Traceback file in case of scoring failure.
        
        # See if done yet.
        if IO.isfile(scfi): scored.append((name,scfi)) # Scored already.
        elif not IO.isfile(outf) and not IO.isfile(f): # Not done yet.
            continue
        
        elif not IO.isfile(f): # Some output was generated by program; probably failed.
            failed.append(name)
            fdetails.append('Executable %s failed before scoring %s. Check output <%s>.' % (
                exe.plugin.default_exe,name,outf))
            
        elif not IO.isfile(scfi) and not name in failed: # Completed successfully.

            try: # Try to perform scoring.
                
                # Perform any post-processing (plugin-dependent).
                if exe.plugin.postprocess:
                    exe.plugin.postProcess(pdbf,ref,logf)
                
                # Score the alignment and write to file.
                sc = scoring.score(pdbf,f,exe,logf)
                if sctype is None and len(sc) > 0:
                    sctype   = sc[0].getName()
                scores[name] = sc[0].getScore()
                pvals[name]  = sc[0].getPValue()
                scoref = scoring.scoreFile(scfi)
                scoref.addScores(sc)
                scoref.writeToFile()
                
            except Exception,e: # Something happened while scoring.
            
                fdetails.append('Failed scoring %s because of an error. Traceback dumped <%s>.' % (
                    name,trbf))
                o = open(trbf,'w')
                o.write('Traceback dumped while scoring %s at %s.' % (
                    name,timeToString()))
                o.write('\n\n' + str(traceback.format_exc()))
                o.close()
                failed.append(name)
                continue
            
            if pvals[name] == None:
                logf.writeTemporary('Scored %s <%s: %s, p-value: ---->.' % (
                    name,sctype.lower(),str(scores[name])[:5]))
            else:
                logf.writeTemporary('Scored %s <%s: %s, p-value: %.6f>.' % (
                    name,sctype.lower(),str(scores[name])[:5],pvals[name]))
                
            IO.remove(outf) # Removes its stdout file if succeeded.
            scored.append((name,scfi))
            logf.incrementTimer()
    
    # Check to see if done all needed files.
    if (len(scored) + len(failed)) >= (len(args)-1):
        
        def buildFailedString():
            # Return condensed listing of everything that failed.
            if len(failed) > 10:
                return ', '.join(failed[:5]) + ', ..., ' + ', '.join(failed[-5:])
            return ', '.join(failed)
        
        # Report all failures (this is to ensure it is only done once).
        for fd in fdetails: logf.write(fd)
        if len(failed) > 0:
            logf.write('Reference trial %s had %d sequences (%s) that failed to align.' 
                       % (rf,len(failed),buildFailedString()), status='WARNING')        
        else: logf.write('Reference trial %s had no sequences that failed to align.' % (rf))
        
        # Score all pairwise alignments together for the reference.
        highpv = 0 # Number of high p-values.
        for name,scfi in scored:
            # If not already cached...
            if not name in scores:
                scoref = scoring.scoreFile(scfi)
                sc = scoref.getScores()
                if sctype is None and len(sc) > 0:
                    sctype = sc[0][0]
                scores[name] = sc[0][1]
                pvals[name]  = sc[0][2]
            # See if high P-value.
            if pvals[name] and pvals[name] > 0.95:
                highpv += 1
                scores[name] = None
                
        # Flatten all RRMSD values into a linear array.
        flatten = [scores[x] for x in scores if scores[x]]
        if len(flatten) == 0: avgscr = -1
        else: avgscr = sum(flatten)/float(len(flatten))        
        if sctype != 'RMSD' and sctype != 'RRMSD':
            flatten = [(1-x) for x in flatten] # Flip directions of floats.
            if avgscr >= 0:
                rank = (sum(flatten)/float(len(flatten))) * (highpv+1)
            else: rank = -1 * (highpv+1)
        else: rank = avgscr * (highpv+1)
        
        # Write score vector reference report.
        picklf = ref.refPicklPath()
        o = open(picklf,'w')
        cPickle.dump((scores,avgscr,highpv,rank,sctype),o)
        o.close()
        logf.write('Coverage of reference complete (%d succeeded, %d failed).' 
                   % (len(scored),len(failed)))
        
        # Report success.
        if (len(failed) != len(args)-1):
            logf.write('Scored %s successfully! Dumped to pickle file <%s>.' % (rf,picklf))
        else: logf.write('Scored %s but no alignments were successfully scored.' % (rf))
        return True
    
    return False

# Run an alignment.

def run(args,logf,ref=None,exe=None,quick=None,recursivecall=False):
    
    ''' Runs an alignment; depends on a list of files to align, a logfile instance,
    an exewrapper instance, and has optional parameters. '''

    # Determine what is done.
    folders_out, i = [], 0

    # Handle reference(s).  
    if quick and not recursivecall:
        refs = quick.get() # Use quick reference search method.
    else: 
        if isinstance(ref,str): refs = [ref] # Specific reference provided?
        else: refs = ref.get() # If is a referenceCollection instance.
    if len(refs) == 0:
        refs = args # No reference provided in list; do n^2 search.

    def checkAll():
        for r in [x for x in refs if not IO.getFileName(x) in folders_out]:
            f = handleReference(args,reference(r),exe,logf)
            if f: folders_out.append(IO.getFileName(r))
        exe.cleanup() # cleanup any files

    # Report reference list.
    for ref in refs: logf.write('Reference: %s' % (ref))
    logf.write('-'*66)

    # Execute and score for every reference.
    for ref in refs:
        i += 1
        refobj = reference(ref)
        reffldr = refobj.folder_name
        if refobj.isScored():
            folders_out.append(reffldr)
            logf.writeTemporary('Reference %s trial alignments already done.' % (reffldr))
            logf.updateTimer(logf.numat+2*(len(args)-1))
            continue
        # Execute command; abstracts multi-processing if necessary.
        exe.plugin.executeCmd(args,ref,exe,logf)
        if ((exe.numcores == 0) or ((i % exe.numcores) == 0)): checkAll()
    
    # If done executing (e.g., all to Fester), wait around and score as files
    # are output from running alignments.
    logf.writeTemporary('All jobs have been submitted.')
    while (len(folders_out) != len(refs)): checkAll()
    
    # Be prepared to store all average scores for references.
    refdict = {}
    
    # If quick reference, have to manage further executions.
    if quick:
        for ref in refs:
            # Get score vector from file.
            refobj = reference(ref)
            avgscr, minref, maxref, _, _ = refobj.getScores()
            if avgscr >= 0:
                refdict[ref] = avgscr
                for x in [minref,maxref]:
                    if x != -1: # If (x == -1), nothing was found.
                        fargs = [IO.getFileName(i) for i in args]
                        toref = x[x.rfind('.')+1:]
                        if toref in fargs:
                            recref = fargs.index(toref)
                        else:
                            logf.write('Quick search reference <%s> missing.' % (toref), status='WARNING')
                            continue
                        if args[recref] in refdict: continue
                        r = run(args,logf,ref=args[recref],exe=exe,recursivecall=True)#,quick=quick)
                        if len(r[0]) > 0:
                            refdict[args[recref]] = r[0][args[recref]]
                            folders_out.extend(r[1])
            else: logf.write('%s found to be insignificant for use as reference.' % (
                IO.getFileName(ref)), status='NOTE')
    else:
        for ref in refs:
            refobj = reference(ref)
            avgscr = refobj.getScores(onlyAvg=True)
            if avgscr >= 0: refdict[ref] = avgscr
            else: logf.write('%s found to be insignificant for use as reference.' % (
                IO.getFileName(ref)), status='NOTE')             
    
    if not recursivecall:
        print '' # Newline to console.
        for ref in refdict:
            # Report on findings to log file.
            logf.write('%s average score found to be %f.' \
                       % (IO.getFileName(ref),refdict[ref]))
            
    return (refdict, folders_out)

# Parse an alignment.

def parse(args,refdict,logf,mostsig=True):
   
    ''' Parse an alignment run by the respective method. '''
    
    # See if anything to parse.
    if len(refdict) == 0:
        logf.write('No significant references were found! Prematurely stopping alignment.', 
            status='ERROR')
        return None, None
    
    # Determine the best reference.
    bestref = None
    for ref in refdict:
        R = reference(ref)
        avg, _, _, highpv, rank = R.getScores()
        if not bestref: bestref = [ref, rank, highpv]
        else:
            if mostsig and (highpv < bestref[2] or \
                            (highpv == bestref[2] \
                             and rank < bestref[1])):
                    bestref = [ref, rank, highpv]
            elif not mostsig and rank < bestref[1]:
                bestref = [ref, rank, highpv]
    reffldr = IO.getFileName(bestref[0])
    logf.write('Best reference found to be %s (%s).' % (reffldr,bestref[0]))
    logf.write('%s: rank measure %f.\n' % (reffldr,bestref[1]))
    
    return bestref, reffldr
